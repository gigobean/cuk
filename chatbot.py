# -*- coding: utf-8 -*-
"""chatbot_20250608.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LfK6GGiszGPRr63RqJor6quGj2dZq0mG
"""

!pip install python-Levenshtein

import pandas as pd
import Levenshtein

# 챗봇 클래스를 정의
class SimpleChatBot:
    # 챗봇 객체를 초기화하는 메서드, 초기화 시에는 입력된 데이터 파일을 로드
    def __init__(self, filepath):
        self.questions, self.answers = self.load_data(filepath)

    # CSV 파일로부터 질문과 답변 데이터를 불러오는 메서드
    def load_data(self, filepath):
        data = pd.read_csv(filepath)
        questions = data['Q'].tolist()
        answers = data['A'].tolist()
        return questions, answers

    # 입력 문장에 가장 잘 맞는 답변을 찾는 메서드
    def find_best_answer(self, input_sentence):
        best_question_index = None # 가장 유사한 질문의 인덱스값이 들어갈 변수 선언 + 초기값은 NONE으로 지정
        best_distance = float('inf')  # 최소거리를 구해 적용할 변수: 가장 최소 거리가 나올때까지 비교하도록 최초에 가장 큰 수(무한대)로 초기화합니다.

        # 모든 질문과 레벤슈타인 거리를 계산
        for i, question in enumerate(self.questions): #enumerate로 i에 인덱스를, question에 각 질문들을 반환합니다.
            distance = Levenshtein.distance(input_sentence, question) #사용자가 입력한 input_setence와 데이터파일에 있는 각 질문(question)과 레벤슈타인 거리를 계산합니다.
            if distance < best_distance: # 이번 회차에 계산된 distance가 지금까지 반복 계산된 값들보다 작으면 best_distance를 갱신합니다.
                best_distance = distance
                best_question_index = i
        # for문의 반복종료 조건은 없음, 모든 질문과 대조후에 가장 작은 거리값만 갱신하고 종료
        return self.answers[best_question_index] # 가장 작은 레벤슈타인거리 값을 가진 인덱스의 질문을 반환

# 데이터 파일의 경로를 지정합니다.
filepath = 'ChatbotData.csv'

# 챗봇 객체를 생성합니다.
chatbot = SimpleChatBot(filepath)

# '종료'라는 입력이 나올 때까지 사용자의 입력에 따라 챗봇의 응답을 출력하는 무한 루프를 실행합니다.
while True:
    input_sentence = input('You: ')
    if input_sentence.lower() == '종료':
        break
    response = chatbot.find_best_answer(input_sentence)
    print('Chatbot:', response)